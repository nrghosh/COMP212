(*  COMP 212 Homework 7:  Datatype definitions.
*
*   Nikhil Ghosh
*   Fall 2016
*)

structure Hw7 =
struct

  exception Unimplemented

  type point = real*real

  datatype shape = Circle of point*real
                 | Rect of point*point
                 | Union of shape*shape
                 | Diff of shape*shape
                 | Translate of shape*real*real
                 | Scale of shape*real*real
                 | Intersect of shape*shape

  (*  dist(a, b) returns distance between two points
  *)
  fun dist((x0, y0) : point, (x1, y1) : point) : real =
  let
    val a = x1 - x0
    val b = y1 - y0
  in
    Math.sqrt(a*a + b*b)
  end


  (*  contains(s, p) = true if p is contained in s, false otherwise.
  *   Points on the boundary of s are consisered to be in s.
  *)
  fun contains(s : shape, p as (x, y): point) : bool =
     case s of
         Circle(a, r) => dist(p, a) <= r
       | Rect((llx, lly), (urx, ury)) =>
           llx <= x andalso x <= urx andalso lly <= y andalso y <= ury
       | Union(s1, s2) => contains(s1, p) orelse contains(s2, p)
       | Diff(s1, s2) => contains(s1, p) andalso not (contains(s2, p))
       | Scale(s, fx, fy) => contains(s, (x/fx, y/fy))
       | Translate(s, a, b) => contains(s, ((x-a, y-b)))


  (*  bb(s) = (ll, ur), where Rect(ll, ur) is the smallest rectangle containing
  *   s.
  *)
  fun bb(s : shape) : point*point =
    case s of
         Circle((x, y), r) => (((x - r), (y - r)), ((x + r), (y + r)))
       | Rect(ll, ur) => (ll, ur)
       | Union(s1, s2) =>
           let
              val ((llx, lly), (urx, ury)) = bb(s1)
              val ((llx2, lly2), (urx2, ury2)) = bb(s2)
           in ((Real.min(llx, llx2), Real.min(lly, lly2)),
               (Real.max(urx, urx2), Real.max(ury, ury2)))
           end
       | Diff(s1, _) => bb s1
       | Scale(s, fx, fy) =>
           let
             val ((llx, lly), (urx, ury))  = bb(s)
           in
             ((llx*fx, lly*fy), (urx*fx, ury*fy))
           end
       | Translate(s, a, b) =>
           let
             val ((llx, lly), (urx, ury)) = bb(s)
           in
             ((llx + a, lly + b), (urx + a, ury + b))
           end

  (*  sierpinskiTri(s, n) = the Sierpinski triangle generated by n iterations
  *   from s.  See assignment for details.
  *)
  fun sierpinskiTri(s : shape, n : int) : shape =
    case n of
        0 => s
       |_ =>
           let
             val s' = sierpinskiTri(s, n-1)
             val ((llx, lly), (urx, ury)) = bb s'
             val width' = urx - llx
             val height' = ury - lly
             val q = Translate(s', ~llx, ~lly)
             val s0' = Scale(q, 0.5, 0.5)
             val s0 = Translate(s0', llx, lly)
             val w = width'/2.0
             val h = height'/2.0
             val s1 = Translate(s0, w, 0.0)
             val s2 = Translate(s0, 0.5*w, h)
           in
             Union(s0, Union(s1, s2))
           end


  (*  An example shape.  To see if you have implemented contains correctly,
  *   execute
  *     writeshape(200, 200, bowtie, "output.bmp").
  *   You should get the picture shown in the assignment.  Then to see if you
  *   have implemented bb correctly, try
  *     writeshape_bb(bowtie, "output.bmp")
  *)
  val bowtie = Union(Rect((0.0,0.0),(100.0,100.0)),
                   Union(Rect((100.0,100.0),(200.0,200.0)),
                              Circle((100.0,100.0),40.0)))

  (*  Another example shape.  Write this out to a file with
  *     writeshape(415,285, cat,"output.bmp")  Then to see if you have
  *   implemented bb correctly, try
  *       writeshape_bb(cat, "output.bmp")
  *)
  val cat =
  let
    val b = Rect((100.0,50.0),(250.0,150.0))
    val t = Rect((250.0,120.0),(375.0,135.0))
    val h = Circle((100.0,175.0),60.0)
    val es = Rect((75.0,205.0),(125.0,250.0))
    val le = Circle((75.0,175.0),5.0)
    val re = Circle((125.0,175.0),5.0)
    val lre = Union(le, re)
  in
    Union(Union(b, t), Diff(h, Union(es,lre)))
  end

  val sierpinski =
  let
    val r = Rect((0.0, 0.0), (150.0, 150.0))
  in
    sierpinskiTri(r, 4)
  end



  (*  writeshape (w, h, s, filename) = ().  As a side-effect, a bitmap file is
  *   written to filename of width w and height h.  The pixel (x, y) is black if
  *   contains(s, (x, y)) and white otherwise.
  *)
  fun writeshape (
      width : int,
      height : int,
      s : shape,
      filename : string) : unit =
    Bitmap.write_bitmap (
      width,
      height,
      fn (x, y) => contains (s,(real x, real y)),
      filename)

  (*  writeshape_bb (s, filename) = ().  As a side-effect, a bitmap file is
  *   written to filename.  The width and height are such that the upper
  *   right-hand corner of bb(s) is the upper right-hand corner of the bitmap.
  *   The pixel (x, y) is black if contains(s, (x, y)) and white otherwise.
  *
  *   Pre-condition:  if (llx, lly) is the lower left-hand corner of bb(s),
  *   then 0 <= llx and 0 <= lly.
  *)
  fun writeshape_bb (s : shape, filename : string) : unit =
  let
    val ((minx,miny),(maxx,maxy)) = bb s
  in
    writeshape (Real.ceil(maxx+minx),Real.ceil(maxy+miny),s,filename)
  end

end
